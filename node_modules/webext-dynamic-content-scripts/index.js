var _a, _b, _c;
import registerContentScriptPonyfill from 'content-scripts-register-polyfill/ponyfill.js';
import { getAdditionalPermissions } from 'webext-additional-permissions';
import { injectContentScript } from 'webext-content-scripts';
const registeredScripts = new Map();
const registerContentScript = (_c = (_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.browser) === null || _a === void 0 ? void 0 : _a.contentScripts) === null || _b === void 0 ? void 0 : _b.register) !== null && _c !== void 0 ? _c : registerContentScriptPonyfill;
// In Firefox, paths in the manifest are converted to full URLs under `moz-extension://` but browser.contentScripts expects exclusively relative paths
function convertPath(file) {
    const url = new URL(file, location.origin);
    return { file: url.pathname };
}
function injectOnExistingTabs(origins, scripts) {
    if (origins.length === 0) {
        return;
    }
    chrome.tabs.query({
        url: origins,
    }, tabs => {
        for (const tab of tabs) {
            if (tab.id) {
                void injectContentScript(tab.id, scripts);
            }
        }
    });
}
// Automatically register the content scripts on the new origins
async function registerOnOrigins({ origins: newOrigins, }) {
    const manifest = chrome.runtime.getManifest().content_scripts;
    if (!manifest) {
        throw new Error('webext-dynamic-content-scripts tried to register scripts on th new host permissions, but no content scripts were found in the manifest.');
    }
    // Register one at a time to allow removing one at a time as well
    for (const origin of newOrigins || []) {
        for (const config of manifest) {
            const registeredScript = registerContentScript({
                js: (config.js || []).map(file => convertPath(file)),
                css: (config.css || []).map(file => convertPath(file)),
                allFrames: config.all_frames,
                matches: [origin],
                excludeMatches: config.matches,
                runAt: config.run_at,
            });
            registeredScripts.set(origin, registeredScript);
        }
    }
    injectOnExistingTabs(newOrigins || [], manifest);
}
(async () => {
    void registerOnOrigins(await getAdditionalPermissions({
        strictOrigins: false,
    }));
})();
chrome.permissions.onAdded.addListener(permissions => {
    if (permissions.origins && permissions.origins.length > 0) {
        void registerOnOrigins(permissions);
    }
});
chrome.permissions.onRemoved.addListener(async ({ origins }) => {
    if (!origins || origins.length === 0) {
        return;
    }
    for (const [origin, script] of registeredScripts) {
        if (origins.includes(origin)) {
            // eslint-disable-next-line no-await-in-loop
            void (await script).unregister();
        }
    }
});
